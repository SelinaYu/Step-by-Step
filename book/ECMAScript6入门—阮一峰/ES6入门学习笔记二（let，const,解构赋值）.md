# ES6入门学习笔记二（let，const,解构赋值）

标签（空格分隔）： ES6

---

<h3>let命令</h3>
用来声明变量，声明的变量仅在块级作用域内有效。
```
var a = [];
for(let i = 0; i < 10;i++){
    a[i] = function(){
      console.log(i);
    };
}
a[6](); //6
```
上面`i`是`let`声明的，当前`i`只在本轮循环有效，所以每次循环的`i`其实都是一个新的变量。
**注意：**
1）`let`不存在变量提升
2）暂时性死区。只要块级作用域内存在`let`命令，它声明的变量就绑定这个区域。在块级作用域声明前就使用这些变量，就会报错。（在代码块，使用`let`命令声明之前，该变量都是不可用的，语法上称为“暂时性死区”）
3）`let`不允许在相同作用域，重复声明同一个变量。
<h3>ES6的块级作用域</h3>
**为什么需要块级作用域**
1）内层变量可能会覆盖外层变量(如下变量提升，导致内层的变量覆盖了外层的tmp变量)
```
var tmp = new Date();

function f(){
  console.log(tmp);
  if (false){
    var tmp = "hello world";
  }
}

f() // undefined
```
2）用来计数的循环变量泄露为全局变量
**ES6块级作用域**
1）外层代码块不受内层代码块的影响
2）允许块级作用域的任意嵌套
3）外层作用域无法读取内层作用域的变量
4）内层作用域可以定义外层作用域的同名变量
5）函数本身的作用域，在其所在的块级作用域之内
<h3>const命令</h3>
`const`用来声明常量，一旦声明，常量的值就不能改变。
**注意：**
1）使用const声明常量后，重新对其赋值。严格模式会报错，常规模式不会报错，但是无效。
2）const一旦声明变量，就必须立即初始化。因此只声明不赋值，严格模式就会报错，常规模式不会报错，但是无法重新赋值。
3）对于复合类型的变量，变量名不指向数据而是指向数据所在的地址，所以不保证该地址的数据不变。
4）如果真的要将对象冻结，应该使用`Object.freeze`。
```
const foo = object.freeze({});
//常规模式，下一行不起作用
//严格模式，该行报错
foo.prop = 123;
```
4）和let命令一样，只在声明所在的块级作用域内有效，变量不提升，存在暂时性死区，不允许在相同作用域重复声明同一个变量
<h3>全局对象的属性</h3>
在ES5中，全局对象(浏览器是指`window`对象，Node.js指的是`global`对象)的属性和全局变量是等价的。（对Node来说，这一条支队REPL环境适用，模块环境之中，全局变量必须显式声明成功`global`对象的属性）
在ES6中，var命令和function命令声明的全局变量，依旧是全局对象的属性。而使用`let`命令，`const`命令，`class`命令声明的全局变量，不属于全局对象的属性。
<h3>解构赋值</h3>
<h4>数组解构赋值</h4>
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，称为解构。
ES6允许写成下面这样
```
let[x,...y] = [1,2,3,4];
x  //1
y  //[2,3,4]
```
注意：
1）如果等号的右边不是数组（或者严格地的说，不是可遍历的解构），那么将会报错。只要某种数据解构具有Iterator接口，都可以采用数组形式的解构赋值。
```
//报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```
2）解构赋值允许指定默认值,ES6内部使用严格相等运算符（`===`）判断一个位置是否有值，所以，如果一个数组成员不严格等于`undefined`，默认值不会生效。

```
var [foo = true] = [];
foo   //true
var [x = 1] = [undefined];
x  //1
var [x = 1] = [null];
x  //null
```
<h4>对象的解构赋值</h4>
数组和对象的解构区别：
数组的元素是按次序排列的，变量的取值是由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能渠道正确的值。 
```
var {foo:baz} = {foo: "aaa",bar: "bbb"}
baz // "aaa"
```
可以看出对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。
对已经声明的变量用于解构赋值，必须非常小心。
```
var x;
//错误的写法,JavaScript引擎将{x}理解成代码块，从而发生语法错误。
{x} = {x:1}
//正确的写法
({x} = {x:1})
```
<h3>字符串的解构赋值</h3>
字符串会被转换成一个类似数组的对象，该对象都有一个`length`属性。
```
const [a,b,c,d,e] = 'hello';

let {length: len} = 'hello';
len   //5
```
<h4>数值和布尔值的解构赋值</h4>
解构复制的规则是，只要等号右边的值不是对象，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对他们进行解构赋值，会报错。
<h3>函数参数的解构赋值</h3>
区别为变量指定默认值和为函数参数指定默认值
```
function move({x = 0, y = 0} = {}) {//竟有变量默认赋值，也有参数默认赋值
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```
只有参数默认赋值
```
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```
`undefined`就会触发函数参数的默认值。
```
[1, undefined, 3].map((x = 'yes') => x)
// [ 1, 'yes', 3 ]
```