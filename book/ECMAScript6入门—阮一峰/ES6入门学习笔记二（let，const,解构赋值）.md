# ES6入门学习笔记二（let，const,解构赋值）

标签（空格分隔）： ES6

---

<h3>let命令</h3>
用来声明变量，声明的变量仅在块级作用域内有效。
```
var a = [];
for(let i = 0; i < 10;i++){
    a[i] = function(){
      console.log(i);
    };
}
a[6](); //6
```
上面`i`是`let`声明的，当前`i`只在本轮循环有效，所以每次循环的`i`其实都是一个新的变量。
**注意：**
1）`let`不存在变量提升
2）暂时性死区。只要块级作用域内存在`let`命令，它声明的变量就绑定这个区域。在块级作用域声明前就使用这些变量，就会报错。（在代码块，使用`let`命令声明之前，该变量都是不可用的，语法上称为“暂时性死区”）
3）`let`不允许在相同作用域，重复声明同一个变量。
<h3>ES6的块级作用域</h3>
**为什么需要块级作用域**
1）内层变量可能会覆盖外层变量(如下变量提升，导致内层的变量覆盖了外层的tmp变量)
```
var tmp = new Date();

function f(){
  console.log(tmp);
  if (false){
    var tmp = "hello world";
  }
}

f() // undefined
```
2）用来计数的循环变量泄露为全局变量
**ES6块级作用域**
1）外层代码块不受内层代码块的影响
2）允许块级作用域的任意嵌套
3）外层作用域无法读取内层作用域的变量
4）内层作用域可以定义外层作用域的同名变量
5）函数本身的作用域，在其所在的块级作用域之内
<h3>const命令</h3>
`const`用来声明常量，一旦声明，常量的值就不能改变。
**注意：**
1）使用const声明常量后，重新对其赋值。严格模式会报错，常规模式不会报错，但是无效。
2）const一旦声明变量，就必须立即初始化。因此只声明不赋值，严格模式就会报错，常规模式不会报错，但是无法重新赋值。
3）对于复合类型的变量，变量名不指向数据而是指向数据所在的地址，所以不保证该地址的数据不变。
4）如果真的要将对象冻结，应该使用`Object.freeze`。
```
const foo = object.freeze({});
//常规模式，下一行不起作用
//严格模式，该行报错
foo.prop = 123;
```
4）和let命令一样，只在声明所在的块级作用域内有效，变量不提升，存在暂时性死区，不允许在相同作用域重复声明同一个变量
<h3>全局对象的属性</h3>
在ES5中，全局对象(浏览器是指`window`对象，Node.js指的是`global`对象)的属性和全局变量是等价的。（对Node来说，这一条支队REPL环境适用，模块环境之中，全局变量必须显式声明成功`global`对象的属性）
在ES6中，var命令和function命令声明的全局变量，依旧是全局对象的属性。而使用`let`命令，`const`命令，`class`命令声明的全局变量，不属于全局对象的属性。





