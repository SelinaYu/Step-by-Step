# 浏览器缓存知识学习笔记

标签（空格分隔）： 其他

---

浏览器缓存，也就是客户端缓存。

**<h3>浏览器缓存基本认识</h3>**

分为**强缓存**和**协商缓存**：
1）浏览器在加载资源时，先根据这个资源的一些Http的头信息判断它是否是强缓存，强缓存如果命中，浏览器不会发送请求到服务器，而是从自己的缓存中读取资源。

2)当强缓存没有命中时，浏览器一定会发送一个请求到服务器，通过头信息验证是否命中协商缓存，如果协商缓存命中，服务器会将请求返回，但是**不会**返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，最后浏览器还是从自己的缓存中加载这个资源。

3)强缓存和协商缓存的共同点是：如果命中都是从客户端缓存中加载资源，而不是服务器加载。区别是：强缓存不发请求到服务器，协商缓存会请求到服务器。

4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。
**<h3>强缓存原理</h3>**

当浏览器命中强缓存时，返回的http状态为200，在chrome的开发者工具的network会显示为`from cache`。
强缓存是利用`Expires`和`Cache-Control`这两个http的header实现的，它们都用来表示资源在客户端缓存的有效期。
`Expires`表示资源过期时间的header,它描述的是一个绝对时间，有服务器返回，用GMT格式的字符表示.

**`Expires`的缓存原理：**
1） 第一次请求资源时，服务器返回这个资源的同时，在respone的header加上Expires的header
2） 浏览器接受资源后，会把这个资源连同所有的header一起缓存下来
3）浏览器在请求这个资源时，先从缓存中寻找，找到这个资源后，拿出他的`Expires`跟当前的请求时间比较，如果请求时间在`Expires`指定的时间之前，就能命中缓存，否则不行。
4）如果缓存没有命中，浏览器直接从服务器加载资源时，`Expires`同时会被更新。

`Expires`是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000`，**`Cache-Control`的缓存原理和`Expires`的差不多，区别主要在第3）步的时候：**

浏览器从缓存中找到这个资源之后，根据它第一次的请求时间和`Cache-Control Header`设定的有效期，计算出一个资源过期时间。再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期之前，就能命中，否则不行。

注意：这两个header可以只启用一个，也可以同时启用。当两者同时存在时，，`Cache-Control`优先级高于`Expires`
**<h3>协商缓存原理</h3>**

当浏览器命中协商缓存时，请求响应返回的http状态为304并且显示一个`Not Modifined`的字符串。
协商缓存利用的是`Last-Modified,If-Modified-Since`和`ETag、If-None-Match`这两对Header来管理。

**`Last-Modified,If-Modified-Since`的缓存原理：**

1）第一次请求资源时，服务器返回这个资源的同时，在respone的header加`Last-Modified`的header，这个header表示这个资源在服务器上的最后修改时间。

2）再次向服务器请求这个资源时，在`request`的header上加上`If-Modified-Since`的header,这个header的值就是上一次请求时返回的`Last-Modified`的值。

3）服务器再次收到资源请求时，根据浏览器传过来`If-Modified-Since`和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回`304 NotModified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回`304 Not Modified`的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么`Last-Modified`也就不会改变。

4) 浏览器收到304的响应后，就会从缓存中加载资源。

5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，
`Last-Modified Header`在重新加载的时候会被更新，下次请求时`，If-Modified-Since`会启用上次返回的`Last-Modified`值。

有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是`ETag、If-None-Match`。

**`ETag、If-None-Match`的缓存原理：**
1） 第一次请求资源时，服务器返回这个资源的同时，在respone的header加`Last-Modified`的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系。

2）再次向服务器请求这个资源时，在`request`的header上加上`If-None-Match`的header,这个header的值就是上一次请求时返回的`ETag`的值。

3） 服务器再次收到资源请求时，根据浏览器传过来`If-None-Match`和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回`304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。与`Last-Modified`不一样的是，当服务器返回`304 Not Modified`的响应时，由于ETag重新生成过，`response` header中还会把这个`ETag`返回，即使这个`ETag`跟之前的没有变化。

`Last-Modified，If-Modified-Since`和`ETag、If-None-Match`一般都是同时启用，这是为了处理`Last-Modified`不可靠的情况。有一种场景需要注意：
分布式系统里多台机器间文件的`Last-Modified`必须保持一致，以免负载均衡到不同机器导致比对失败；
分布式系统尽量关闭掉`ETag`(每台机器生成的ETag都会不一样）；

**浏览器行为对缓存的影响**
在**浏览器缓存基本认识**已经说了默认的处理方式，这个方式有可能被浏览器的行为改变：

- 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当f5刷新网页时，跳过强缓存，但是会检查协商缓存

原文链接：http://www.cnblogs.com/lyzg/p/5125934.html