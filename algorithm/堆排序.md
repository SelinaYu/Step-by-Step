# 堆排序

**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。**

**通常堆是通过一维数组来实现的,通常有以下特点：**


- 父节点下标为 i,
- 父节点左子节点下标 2*i + 1;
- 父节点右子节点下标 2*i + 2;
- 子节点下标为i时 ,父节点 Math.floor((i-1)/2)

```javaScript
function headSort(arr){
  let length = arr.length;
  for(let i = Math.floor(length/2) - 1; i >= 0; i--){
      // 构建堆
      maxHeapify(arr,i,length);
  }
//   for(let j = 0; j < length; j++) { 
//       [arr[0],arr[length - 1 - j]] = [arr[length - 1 - j ],arr[0]];// 最后一个未排序元素和第一个元素交换
//       maxHeapify(arr,0,length - j - 2)
//   }
  for(let j = length - 1; j >= 0;j--) { // 和上面注释的循环效果是一样的
      [arr[0],arr[j]] = [arr[j],arr[0]];
      maxHeapify(arr,0,j - 1);
  }
  return arr;
  function maxHeapify(arr,i,length){
      let left = 2 * i + 1;
      let right = 2* i + 2;
      let largest = i;
      if(left <= length && arr[left] > arr[largest]) {
          largest = left;
      }
      if(right <= length && arr[right] > arr[largest]) {
          largest = right;
      }
      if(largest !== i) {
          [arr[i],arr[largest]] = [arr[largest],arr[i]];  // 遇到比父节点大的子节点，父子节点交换
          maxHeapify(arr,largest,length)
      }
  }
}
```

### 思路过程

1) 构造堆，一般升序采用大顶堆，降序采用小顶堆，从最后一个非叶子节点`(Math.floor(length/2)-1)`开始进行，从左到右，从下到上进行调整。有可能调整后的子堆，不符合
2) 最大堆调整, 将堆顶元素与尾节点交换后，使得尾元素最大,长度减1
3) 重新对剩下的length - 1长度的堆进行最大堆调整，再将堆顶和堆尾元素交换，得到第二大元素。反复执行交换,调整直至整个序列有序