给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

## 解法一 暴力解法

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let result = nums[0];
  for(let i =0; i < nums.length;i++) {
      let sum = 0;
      for(let j = i; j < nums.length;j++){
         sum += nums[j];
         result = Math.max(sum,result);
      }
  }
    return result
};
```
### 解题思路

1) 定义两个变量，result存储最终结果， 最外层循环需要初始sum 为 0，用来计算最大子序列和
2) 内循环每次遍历一个数便进行求和得到sum，和result 比较得到取大值
3) 返回最终结果result。
时间复杂度 O(n2)
## 解法二

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let sum = 0;
    let result = nums[0];
    for(let i = 0;i < nums.length;i++){
        if(sum > 0){
            sum += nums[i];
        } else {
            sum = nums[i];
        }
        result = Math.max(result,sum)
    }
    return result;
};
```

### 解题思路

1) 初始化两个值，一个为最终的结果值result,一个是当前遍历的最大子序列和sum
2) 当sum > 0时，则sum 保留并加上当前字段
3) 当sum <= 0时，则sum 重新开始计算，直接更新当前为遍历数字。因为当sum 小于0，当前数字的值始终会大于 **sum + 当前数字**
4) 比较sum 和 result ，取其最大值
时间复杂度O(n)