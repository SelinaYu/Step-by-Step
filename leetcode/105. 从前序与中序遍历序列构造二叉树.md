根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出


```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

### 递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  if(preorder.length === 0 || inorder.length === 0) {
      return null
  }
  let root = preorder[0];
  root = new TreeNode(root);
  if(preorder.length === 1) return root;
  let rootIndex = 0;
  while(rootIndex < inorder.length && inorder[rootIndex] !== root.val){
      rootIndex++;
  }
  // 左子树
    root.left = buildTree(preorder.slice(1,rootIndex+1),inorder.slice(0,rootIndex));
// 右子树
   root.right = buildTree(preorder.slice(rootIndex + 1),inorder.slice(rootIndex + 1));
   return root;
};
```

### **解题思路**

先了解前序遍历序列和中序遍历序列的特点：
1) 前序遍历序列中，第一个数字总是树的跟节点的值 `root.val`。
2) 中序遍历序列中，根节点的值处于序列的中间，可以用来区分左右子树。
3） 通过遍历 中序遍历序列 ，找到根节点的下标值 `rootIndex`
4） 找到前序遍历序列中，左子树的区间 `[1,rootIndex]`（0是根节点），右子树的区间`[rootIndex + 1, preorder.length -1]`，这两个左右子树都是前序遍历序列。
5) 同理，找到中序遍历序列中，左子树的区间 `[0,rootIndex - 1]` 和 右子树的区间 `[rootIndex + 1, inorder.length - 1]`,这两个左右子树都是中序遍历序列。
6) 接着用同样的方法，分别对已经知道前序遍历序列和中序遍历序列的左右子树构建二叉树。

这个需要注意的是，当序列为空时要返回 null，否则返回 root;