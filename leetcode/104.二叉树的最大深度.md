给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：

给定二叉树 [3,9,20,null,null,15,7]，
```
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

### 解法一 深度递归

```javascript
var maxDepth = function(root) {
    if(root == null) return 0
    let LH = maxDepth(root.left);
    let RH = maxDepth(root.right);
    return LH > RH ? LH + 1 : RH + 1;
    
};
```
可以说这个是最直观的解法了。每遍历一层高度要加一，左子树和右子树取最高的值。

### 深度优先迭代

```javascript
var maxDepth = function(root) {
    if(!root) return 0;
    root.level = 1;
    let stack = [root];
    let depth = 0;
    while(stack.length > 0) {
        let node = stack.pop(); // 先出
        depth = Math.max(depth,node.level)
        if(node.right) {
            node.right.level = node.level + 1;
            stack.push(node.right); // 后进
        }
        if(node.left) {
            node.left.level = node.level + 1;
            stack.push(node.left)
        }

    }
    return depth
};
```

为每个节点添加一个深度属性level,利用栈`stack`后进先出的特点遍历二叉树，定义暂时最深深度depth,没遍历一个节点判断暂时最深深度和当前节点的深度，取最大值 `depth = Math.max(depth,node.level)`,最后返回 `depth`;

### 解法三 广度优先迭代

```javascript
var maxDepth = function(root) {
    if(!root) return 0;
    root.level = 1;
    let queue = [root];
    let depth = 0;
    while(queue.length > 0) {
        let node = queue.shift(); // 模拟队列先进先出
        depth = Math.max(depth,node.level)
        if(node.left) {
            node.left.level = node.level + 1;
            queue.push(node.left)
        }
        if(node.right) {
            node.right.level = node.level + 1;
            queue.push(node.right)
        }
    }
    return depth
};
```
为每个节点添加一个深度属性level,利用队列`queue`先进先出的特点遍历二叉树，定义暂时最深深度depth,没遍历一个节点判断暂时最深深度和当前节点的深度，取最大值 `depth = Math.max(depth,node.level)`,最后返回 `depth`;

### 小结
 无论是深度优先迭代还是广度优先迭代，其实最后都是把二叉树节点遍历一遍，比较他们的深度`level`，取其最大值。


