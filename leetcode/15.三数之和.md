# 三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```




## 方法1 暴力解法 （超时限制）
```javascript
var threeSum = function(nums) {
    const result = [];
    let map = new Map();
    for(let i = 0; i < nums.length - 2; i++){
        for(let j = i + 1; j < nums.length - 1; j++) {
            for (let k = j + 1; k < nums.length; k++) {
                if(nums[i] + nums[j] + nums[k] === 0){
                    let temp = [nums[i],nums[j],nums[k]].sort((a,b) => a-b).join(',');
                    if(map.get(temp) === undefined){
                      result.push([nums[i],nums[j],nums[k]]);
                    } 
                    map.set(temp,true)
                }
            }
        }
    }
    return result;
};
```
### **解题思路**

这个思路真的很简单粗暴，虽然我已经预感到会超时，还是尝试下实现。:joy: :joy:  

主要是三个循环遍历数组，然后判断这三遍循环对应元素的和是否为0。需要注意的是答案中不可以包含重复的三元组。所以符合要求的三元组做个标记【map.set(temp,true)】,结果添加三元组的时候，判断是否已经被标记过。

### 排序 + 双指针


```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort((a,b) => a - b);
  let result = [];
  for(let i = 0; i < nums.length;i++){
      if(nums[i] > 0) break; // 最小都大于0，则三数和不可能为0
      if(i > 0 && nums[i] === nums[i-1]) continue; // 去重
      let target = 0 - nums[i];
      let l = i + 1;
      let r = nums.length - 1;
      while(l < r){
        if(nums[l] + nums[r] === target) {
          result.push([nums[i],nums[l],nums[r]]);  
          while(l < r && nums[l + 1] === nums[l] ) l++;  // 以防三元组重复
          while(l < r && nums[r -1] === nums[r]) r--;
          l++;
          r--;
        } else if(nums[l] + nums[r] > target) {
            r--;
        } else {
            l++;
        }
      }
  }
    return result;
};
```

### **解题思路**

这种解法和两数之后有点相似。
1) 对数组进行排序
2) 遍历数组，进行设置一个目标 target = 0 - X;
3) 对数组剩下的元素，使用双指针方法，筛选两个数字的和是否等于target，等于的话，则添加到result数组里。不等于则继续遍历
4) 需要的注意的是答案不包含重复的三元组，所以要去重，只要有两个元素重复，则跳过。

