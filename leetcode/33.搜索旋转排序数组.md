假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

```
示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

## **解题思路**

从数组中搜索给定的一个目标值，最简单的方法就是遍历。这里需要注意的是算法时间复杂度必须是O(logn) 级别。所以这里采用了而二分查找的方法。

1) 采用二分查找找到数组旋转的下标ratate_Index的值 rIndex,划分出左递增数组 和 右递增数组
2) 拿出数组arr[0] 和target进行比较，因为这是一个分界点。

- 当target 小于 arr[0],则说明目标值target可能(可能数组中没有这种值)在右递增数组，对右递增数组进行二分查找，左指针指向 rotate_Index, 右指针指向 arr.length - 1;
- 当target 大于或等于 arr[0]，则说明target可能存在左递增数组，左指针指向0，右指针指向rIndex - 1;

这里还有一个需要的点，我们是用arr[0]，数组第一个值确认target在左递增或者右递增数组和 rotate_Index 进行划分左右递增数组区间的，所以需要对特殊情况 **rotate_Index === 0** 的情况进行特殊判断，这种情况其实就是整个数组没有旋转，对整个数组进行二分查找。

### 代码

```javascript
// 二分查找找到旋转下标
function findIndex(nums){
    let left = 0;
    let right = nums.length-1;
    mid = left;
    while(nums[left] >= nums[right]) {
        mid = parseInt((left + right) / 2);
        if(right - left === 1){
            mid = right;
            return mid;
        }
        if(nums[mid] >= nums[left]) {
            left = mid;
        } else if(nums[mid] <= nums[right]) {
            right = mid
        }
    }
    return mid;
}
// 二分查找找到目标值
function binarySearch(nums,target,left,right) {
    while(left <= right) {
        let mid = parseInt((left + right) / 2);
        if(nums[mid] === target) {
            return mid;
        } else if(nums[mid] >target){
            right = mid - 1;
        }else {
            left = mid + 1;
        }
    }
    return -1;
}
var search = function(nums, target) {
  let length = nums.length;
  if(length === 0) return -1;
  if(length === 1) return target === nums[0] ? 0: -1;
  let rIndex = findIndex(nums); // 二分查找找出旋转下标
  let result = 0;
    
  if(rIndex === 0){ // 没有旋转
      result = binarySearch(nums,target,0,length-1);      
  } else if(target < nums[0]) { // 对右边递增数组二分查找
      result = binarySearch(nums,target,rIndex,length - 1)
  } else {
      // 对左边递增数组二分查找
      result = binarySearch(nums,target,0,rIndex - 1 )
  }
  return result;
};
```