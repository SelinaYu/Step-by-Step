给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。


```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

### 方法1 左右子树分别递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    function leftToRight(node){
         if(!node){
            return 'a';
         }
        return `${node.val}${leftToRight(node.left)}${leftToRight(node.right)}`
    }
    function rightToLeft(node){
        if(!node){
            return 'a'
        }
        return `${node.val}${rightToLeft(node.right)}${rightToLeft(node.left)}`
    }
    return leftToRight(root) === rightToLeft(root)
};
```

### **解题思路**

因为二叉树镜像对称，所以左子树从左到右遍历和右子树从右到左遍历出来的结果是一致的。利用这一特性进行递归遍历。比较左右子树递归的结果即可。需要注意的是null的情况需要给一个占位符。

### 方法2 递归二叉树

```javascript
var isSymmetric = function(root) {
  function isMirror(root1,root2){
      if(root1===null && root2 === null) return true;
      if(root1 === null || root2 === null) return false;
      return root1.val === root2.val && isMirror(root1.left,root2.right) && isMirror(root1.right, root2.left)
  }
  return isMirror(root,root)
};
```

### **解题思路**

利用镜像对称的特点：

1) 根节点的值相同

2) 左子树左边的值等于右子树右边的值

3) 左子树右边的值等于右子树左边的值

递归遍历子树，并判断是否满足上面三个特征。