给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

示例 1:

```
输入: dividend = 10, divisor = 3
输出: 3
```

示例 2:

```
输入: dividend = 7, divisor = -3
输出: -2
```

说明:

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。


### 方法一 对数运算

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
        if(dividend == 0)  return 0;

        let a = Math.abs(dividend);
        let b = Math.abs(divisor);

        let result = Math.exp(Math.log(a) - Math.log(b));

        if ((dividend < 0) ^ (divisor < 0)) result = -result;

        let Max = Math.pow(2,31) - 1;
        if (result > Max) result = Max;
        return parseInt(result);
};
```

### **解题思路**


利用对数的公式  a -b = e^(lna-lnb);

先把被除数和除数进行绝对值，然后利用公式求出对应的result;

然后利用异或判断两个数是否是异号，添加符号

最后判断结果是否超出最大值

需要对特殊情况进行处理：
1) 被除数为0的情况
2) 溢出情况


### 方法二 加减法

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */

var divide = function (dividend, divisor) {
    let result = 0, sign = 1, mul = 1;
    if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)) {
        sign = -1;
    }
    dividend = Math.abs(dividend);
    divisor = Math.abs(divisor);
 
    divisor2 = divisor;
 
    while (dividend >= divisor2) {
        if (dividend > (divisor2 + divisor2)) {
            divisor2 += divisor2;
            mul += mul;
        }
        dividend -= divisor2;
        result += mul;
    }
    while (dividend >= divisor) {
        dividend -= divisor;
        result += 1;
    }
 
    if (sign == 1 && result > (Math.pow(2, 31) - 1)) {
        return Math.pow(2, 31) - 1;
    } else if (sign == -1 && result < -Math.pow(2, 31)) {
        return -Math.pow(2, 31);
    }
    if (sign == 1) {
        return result;
    } else {
        return -result;
    }
};
```

### **解题思路**

循环，将除法转换为减法

1) 除数与被除数都初始化为正数，商初始值为 1

2) 循环1：当被除数大于等于除数，除数翻倍，商也翻倍，被除数减去除数，

3) 循环2：当循环1中的除数大于被除数，重新循环，除数为初始的除数，不再翻倍，被除数每次减去一个除数，商每次加一

4) 判断结果是否超出范围限制

5) 返回带符号的结果

  